



Network Working Group                                           D. Jesus
Internet-Draft                                                 J. Leitão
Intended status: Standards Track                                  TaRDIS
Expires: 4 August 2025                                      January 2025


  A Generic Framework for Building Dynamic Distributed Systems (GFDS)
                        draft-tardis-gfds-latest

Abstract

   Building and managing highly dynamic and heterogenous distributed
   systems can prove to be quite challenging due to the great complexity
   and scale of such environments.  This documents specifies a Generic
   Framework for Building Dynamic Distributed Systems (GFDS), which
   composes a reference architecture and execution model for developing
   and managing these systems while providing high level abstractions to
   users.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 5 July 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Overview
     1.1.  Document Structure
   2.  Conventions and Definitions
   3.  Protocol Anatomy
     3.1.  Protocol Initialization
     3.2.  Handlers
       3.2.1.  Timer-Handlers
       3.2.2.  Inter-Protocol Handlers
       3.2.3.  Communication Handlers
     3.3.  Procedures
     3.4.  Example
   4.  Architecture
     4.1.  Event Manager
     4.2.  Configuration Manager
     4.3.  Channel Manager
     4.4.  Security Manager
   5.  Execution Model
   6.  API
   7.  Examples
   8.  Security Considerations
   9.  IANA Considerations
   10. Implementation Status
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Overview

   Building dynamic distributed systems is a complex and challenging
   task due to the inherent unpredictability and scale of such systems.
   These systems often consist of multiple nodes that may be located in
   different geographic regions, and they need to collaborate seamlessly
   to provide services or process data.  The difficulty arises in
   managing issues like network latency, node failures, variable load
   distribution, or even node displacement in particular environments.
   These systems must remain highly available and responsive even when
   individual components experience failures, which requires robust
   fault tolerance and self-healing mechanisms.

   Maintaining scalability and flexibility as the system evolves proves
   to be quite endeavouring as well.  As demand grows, the system must
   be able to dynamically scale by adding or removing nodes without
   disrupting ongoing operations, which requires sophisticated
   orchestration, auto-reconfiguration and adaptability.  Moreover,
   dealing with the complexities of data consistency, synchronization,
   and ensuring that all nodes have a coherent view of the system state
   introduces a level of complexity that can be difficult to manage.

   Establishing frameworks and libraries for developing and managing
   this systems presents significant challenges due to the need to
   abstract the complexities of distributed architectures and the
   management of its intricacies, while still providing enough
   flexibility and control for developers.  Developers often require
   low-level access to certain aspects of the system, such as network
   management, fault tolerance mechanisms, security guarantees, no name
   a few, albeit requiring a flexible and fluid programming model,
   specially for beginners.  Frameworks must provide high-level
   abstractions that simplify common tasks—like managing communication
   between nodes or handling failures, without hiding critical details
   that could lead to performance bottlenecks or incorrect system
   behavior.

   Network libraries such as [lib2p], offer modular and flexible
   networking framework that provides the building blocks for creating
   peer-to-peer networks, however come with a steep learning curve and
   interoperability issues.  Alternatively, simulators like [PeerSim]
   allow developers to quickly develop and test distributed systems, but
   fail to model realist execution environments.

   In this work we propose a Generic Framework for Building Dynamic
   Distributed Systems (GFDS) which aims to offer a set of tools,
   abstractions, and best practices to allow developers to design,
   deploy, and manage distributed applications that are dynamic,
   resilient, scalable, and fault-tolerant.  The framework is composed
   of an execution model that details and controls the life-cycle of
   protocols (the base unit in the framework) and an architecture
   detailing a set of managers to handle the different components and
   their interactions, while providing common APIs for enabling inter-
   protocol communication between the different elements in the stack.

1.1.  Document Structure

   This document describes a Generic Framework for Building Dynamic
   Distributed Systems and its structured as follows:

   *  Section 3 describes the base unit of interaction within the
      framework, the protocol,

   *  Section 4 describes the framework architecture, its different
      components and their interaction,

   *  Section 5 details the execution model of the framework and the
      life cycle of protocols,

   *  Section 6 describes the programming interfaces offered by the
      framework to the application level for inter-protocol
      communication,

   *  Section 7 provides real world scenarios and examples.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Protocol Anatomy

   The main unit of interaction on the framework is the _protocol_.
   Protocols embed the logic implemented by the developer and use the
   abstractions provided by the framework to interact with other
   protocols being executed locally and to handle communication with
   other nodes.  A process may execute an arbitrary number of protocols
   concurrently at any given time, and protocols can communicate with
   each other to cooperate and delegate tasks.  Moreover, as it is very
   common in distributed protocols to capture certain behaviors,
   protocols can execute actions periodically with the use of timers
   (e.g., execute a garbage collection function).

   Each protocol is composed by four main concepts that dictate the
   anatomy and life cycle of a protocol:

   *  *state* which describes the inner state of the protocol,
      containing the necessary data and data structures to ensure its
      correct behavior.  The state should be initialized in a
      specialized _init_ function and can be mutated by means of
      interaction with other local protocols, through periodic timers
      that alter the state of the protocol and finally, through
      communication with other nodes running the some protocol on
      different machines,

   *  *timer handlers* are meant to execute periodic or configured
      tasks.  When the timer expires, a handler is executed with a user
      defined logic.  Additionally, protocols are able to cancel timers
      if they are no longer relevant (e.g., a timer setup by the lack of
      an acknowledgement can be canceled if the acknowledged arrived in
      the mean time),

   *  *inter-protocol handlers* are in charge of managing communication
      between protocols running on the same machine.  These handlers are
      divided into two categories: one-to-one _requests/replies_ and
      one-to-many _notifications_.

   *  *communication handlers* which manages incoming and outgoing
      communication events through different interfaces.  This events
      can materialized as messages, streams or other generic data
      transfer methods.

   Further details regarding the architecture and functionality of
   handlers are provided in Section 4.

   With most of the complexity abstracted by the framework, the
   developer is able to focus on the logic of the protocol, without
   having to worry about the low-level aspects associated with building
   large scale systems (e.g., dealing with faults in the network layer).

3.1.  Protocol Initialization

   As described previously, each protocol should implement a special
   _init_ function.  This function is meant to be executed exactly one
   time during the life-cycle of the protocol, and has three main
   purposes:

   1.  Initialize the protocol's state, namely, its control variables,
       local data structures, etc.,

   2.  Choose the preferred communication interfaces,

   3.  Register the different handlers (i.e., timer, inter-protocol and
       communication handlers).

   A typical protocol initialization would be structured as follows:

init(properties):
  // 1 - Setup initial state
  ...

  // 2 - Communication interface
  preferences = {TCP, BLE}
  registerCommunicationInterfaces(preferences)

  // 3 - Handlers
  registerRequestHandler(BroadcastRequest, uponBroadcastRequest)
  ...

  registerReplyHandler(DeliverReply, uponDeliverReply)
  ...

  registerTimerHandler(GarbageCollectTimer, uponGarbageCollectTimer)
  setupPeriodicTimer(uponGarbageCollectTimer, 100s);
  ...

  registerNotificationHandler(NeighborNotification, uponNeighborNotification)
  ...

  registerMessageHandler(BroadcastMessage, uponBroadcastMessage)
  ...

3.2.  Handlers

3.2.1.  Timer-Handlers

3.2.2.  Inter-Protocol Handlers

3.2.3.  Communication Handlers

3.3.  Procedures

   Beyond the information defined above, protocols may need to execute
   procedures.  This procedures can range from simple calculations on
   specific parameters, or inflations on the local state.  Thus,
   protocols should be allowed to declare an arbitrary number of
   procedures that can then be invoked by the protocol among the
   different handlers defined in the _init_ function.

   The declaration of a procedure should proceed as follows:

   procedureName(args):
     //Perform computations on args

     return result;

   A possible usage of a procedure within a protocol:

   calcIntersection (set1, set2):
     return set1 ^ set2;

   uponSetMessage(SetMessage: msg):
     intersect = this.calcIntersection(this.set, msg.set)
     this.set= intersect
     sendReply(SetUpdateReply(this.set), destProto)

3.4.  Example

4.  Architecture

4.1.  Event Manager

4.2.  Configuration Manager

4.3.  Channel Manager

4.4.  Security Manager

5.  Execution Model

6.  API

7.  Examples

8.  Security Considerations

   (Mandatory chapter)

9.  IANA Considerations

   (Mandatory chapter)

10.  Implementation Status

11.  References

11.1.  Normative References

   [BCP190]   Best Current Practice 190,
              <https://www.rfc-editor.org/info/bcp190>.
              At the time of writing, this BCP comprises the following:

              Nottingham, M., "URI Design and Ownership", BCP 190,
              RFC 8820, DOI 10.17487/RFC8820, June 2020,
              <https://www.rfc-editor.org/info/rfc8820>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

11.2.  Informative References

   [lib2p]    "lib2p", n.d., <https://libp2p.io>.

   [PeerSim]  "PeerSim", n.d., <https://peersim.sourceforge.net>.

Acknowledgments

Authors' Addresses

   Diogo Jesus
   TaRDIS
   NOVA Laboratory for Computer Science and Informatics (NOVA LINCS)
   Email: da.jesus@fct.unl.pt


   João Leitão
   TaRDIS
   NOVA Laboratory for Computer Science and Informatics (NOVA LINCS)
   Email: jc.leitao@fct.unl.pt
